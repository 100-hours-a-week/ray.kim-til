# 딥 다이브 (D+5)
<aside>
💡

## 4. 스레드를 사용하였을 때 장단점을 서술하고 스레드의 생명주기에 대해 서술하시오

### 장점:

- `물리적`인 리소스가 없더라도 운영 체제 계층에서 구현되기 때문에 다중 스레드 생성이 가능하다.
    - 스레드는 실제 하드웨어 리소스가 아닌 운영체제에서 가상 리소스로 동작함
- 다중 프로세스를 할 때보다 다중 스레드를 활용하는 것이 `오버헤드`를 더 줄일 수 있다.
    - 전환 속도 빠름
    - 메모리 공유
- 동시성 혹은 병렬성을 만족하는 실행 흐름을 구현할 수 있다.

### 단점:

- 스레드 수가 많으면 스레드 간 전환에 따른 부담이 증가한다. (컨텐스트 스위칭 비용)
- 스레드마다 각자 독립적인 스택 영역이 필요한데, 많은 수의 스레드를 생성하면 메모리와 기타 시스템 리소스를 너무 많이 소비하게 된다.
- 여러 스레드가 동일한 자원에 동시에 접근하려할 때 데이터의 일관성이 깨질 수 있다.

### 스레드의 생명주기

- 생명주기란 생성과 소멸까지의 시간에 대한 범위 혹은 시점을 나타내는 뜻
- 스레드의 생명 주기는 처리해야할 작업이 있고, 그 작업이 끝날 때까지 유지 된다.

e.g. 워드에서 문서를 쓴다고 하면 데이터를 쓰는 행위 자체가 하나의 작업이기 때문에 디스크 기록 작업을 전담하는 스레드를 생성한다. 해당 스레드의 생명 주기는 워드 프로세스의 생명 주기와 동일하다.

![image](https://github.com/user-attachments/assets/56a9dcfe-6c09-439e-80f4-cc24ca0dd2e0)


| **New (새로운 상태)** | 스레드가 **생성되었으나 아직 시작되지 않은** 상태. |
| --- | --- |
| **Runnable (실행 가능 상태)** | 스레드가 **실행 중이거나 실행될 준비**가 된 상태. |
| **Blocked (차단 상태)** | 스레드가 동기화 **락을 기다리는 상태** |
| **Waiting (대기 상태)** | 스레드가 **무기한으로 다른 스레드의 작업을 기다리는 상태** |
| **Timed Waiting (시간 제한 대기 상태)** | 스레드가 일정 시간 동안 다른 스레드의 작업을 기다리는 상태 |
| **Terminated (종료 상태)** | 스레드의 실행이 완료된 상태 |

## 4-1. 스레드의 교착상태까지 설명 필요

### 교착상태란?

- 여러 `프로세스` 혹은 `스레드`가 아무 일도 못하고 특정 사건을 기다리며, `무기한 연기`되어 있는 상태
- 시간이 지나도 해결되지 않음
- 교착상태를 유발하는 조건을 없애야 해결이 됨

### 교착상태를 유발하는 조건은? (4가지)

1. **상호 배제(Mutual Exclusion) 조건**
    - 자원은 한 번에 한 스레드만 사용할 수 있음 (배타적 사용)
    - 다른 스레드가 자원을 사용 중이면 대기해야 함
2. **점유와 대기(Hold and Wait) 조건**
    - 스레드가 `최소 하나의 자원`을 `점유`한(사용중) 상태에서, 다른 스레드에 의해 점유된 `다른 자원`을 할당 받기를 요구
3. **비 선점(No preemption) 조건**
    - 자신의 작업 수행이 끝날 때까지 해당 자원을 반환하지 않음
4. **환형 대기(Circular Wait) 조건**
    - 프로세스들 간의 환형 대기(순환 형태로 서로의 자원을 기다림)가 존재함

## 4-2. 스레드풀(Thread Pool)에 대해 설명하시오

### 스레드 풀이라는 개념이 왜 등장 했을까?

스레드의 생명 주기가 짧은 상황(네트워크 요청, 데이터베이스 쿼리 등)을 예를 들어보면,

처리 시간이 매우 짧은 작업으로, 단시간에 빠르게 처리되기 때문에 스레드의 생성과 소멸이 빈번하게 일어납니다. 단순히 스레드를 생성하고 종류하면 되겠지라고 생각할 수 있지도 모른다.

이를, `요청당 스레드(thread-per-request)` 라고 하는데 요청마다 매번 스레드가 생성된다는 의미이다. 생명주기가 짧은(짧은 작업)에서는 아래와 같은 문제가 발생한다.

1. 스레드의 생성과 종료에 많은 시간을 허비함
2. 스레드마다 독자적인 스택 영역을 가지고 있는데, 이로 인해 리소스를 많이 소비하게 됨
3. 스레드 수가 많으면 스레드 간 전환에 따른 부담이 증가

이러한 단점을 보완하기 위해 스레드를 `미리 여러개 생성해두고 재사용하는 방식`인 스레드풀이 탄생하게 되었습니다.

## 4-3. 실제로 스레드풀이 동작하는 방식을 간단한 예시로 들어 설명하시오

### 스레드 풀의 동작 방식

- 스레드를 미리 생성해두기 때문에 생성과 종료가 빈번하게 일어나지 않는다.
- 자료구조의 대기열(큐)을 이용하여 작업을 스레드에게 전달한다.
- 작업을 전달하는 것은 생산자이며, 작업을 처리하는 스레드는 소비자이다. 고전적인 생산자-소비자 패턴을 띄고 있다.

![image](https://github.com/user-attachments/assets/92baa40c-9493-4e61-a1de-21012532d473)


**생성자-소비자 패턴(Producer-consumer pattern)**

1. 처리할 작업이 생기면 `생산자(애플리케이션)`가 미리 생성해둔 `스레드(소비자)`에게 처리를 요청한다.
2. 스레드 풀의 스레드는 작업 대기열에서 블로킹 상태로 대기하다 `생산자(어플리케이션)`가 작업 대기열에 작업을 할당하면 스레드 풀의 `스레드(소비자)`가 깨어나고 작업을 시작하게 됨
</aside>

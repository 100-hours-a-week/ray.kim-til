# 블로킹, 논블로킹/ 동기, 비동기 (D+3)
- 블로킹,논블로킹: 차단, 제어권
- 동기, 비동기: 순서, 의존적


<aside>
💡

### 비동기/동기

- 요청한 작업을 내가 기다릴 것인가?
- 요청한 작업이 끝날 때 까지 내가 기다리고
- 다음 작업을 시작할 것인가?
</aside>

- **동기:**
    
    요청한 작업이 끝날 때까지 기다렸다가 다음 작업을 실행함.
    
    **e.g.** 파일 읽기 함수 호출 후, 파일 내용이 반환될 때까지 다른 작업을 하지 않음.
    
- **비동기:**
    
    작업 요청 후 바로 제어권이 돌아와서 다른 작업을 수행할 수 있으며, 작업 완료 시 콜백이나 이벤트로 결과를 알림.
    
    e.g. 파일 읽기 요청 후 바로 다른 작업을 수행하고, 파일 읽기가 끝나면 콜백으로 결과를 받음.
    

### 2. 블로킹 / 논블로킹

<aside>
💡

### 블로킹/논블로킹

- 요청한 작업을 위해 지금 작업을 멈출 것인가?
- 요청한 작업이 끝날 때 까지
- 현재 작업을 멈출 것인가?
</aside>

- **블로킹:**
    
    호출한 작업이 끝날 때까지 호출자가 **대기(제어권을 잃음)** 함.
    
    e.g. 파일 읽는 동안 프로그램의 해당 스레드가 멈춤.
    
- **논블로킹:**
    
    작업 요청 후 바로 제어권이 반환되어 호출자가 다른 작업을 계속할 수 있음.
    
    e.g. 파일 읽기 요청 후, 파일이 준비되지 않았더라도 즉시 반환되어 다른 작업을 수행하고, 파일 읽기가 준비되면 알려줌.
    

### 3. 동기 / 비동기의 차이를 설명하고 파일 읽기 작업을 예시로 들어 설명해주세요

- **동기 파일 읽기:**
    
    ```jsx
    const data = readFileSync('file.txt'); // 파일 읽기 완료 후 data에 내용 할당
    console.log(data); 
    ```
    
    파일 읽기가 끝날 때까지 기다린 후 다음 줄을 실행
    
- **비동기 파일 읽기:**
    
    ```jsx
    javascript
    복사
    readFile('file.txt', (err, data) => {
      if (err) throw err;
      console.log(data); // 파일 읽기가 완료되면 콜백에서 출력
    });
    console.log('파일 읽기 요청 후 바로 실행됨');
    
    ```
    
    파일 읽기 요청 후 바로 다음 코드가 실행되고, 파일 읽기가 완료되면 콜백 함수가 호출
    

### 4. 블로킹과 논블로킹을 제어권 관점에서 설명해주세요.

- **블로킹:**
    
    호출자가 작업을 요청하면, 작업이 완료될 때까지 **제어권을 잃고** 대기
    
- **논블로킹:**
    
    작업 요청 후 **즉시 제어권을 반환**하여 호출자가 다른 작업을 수행할 수 있습니다. 나중에 작업 완료 시 알림을 받d
    

### 5. 동기 + 블로킹과 동기 + 논블로킹 조합의 차이를 설명해주세요.

- **동기 + 블로킹:**
    
    ![image](https://github.com/user-attachments/assets/f0568450-d848-421e-af92-ffdc9b3d31a0)

    
    - 요청 후 결과가 반환될 때까지 **완전히 기다림**
    - 코드가 순차적으로 진행되고, 호출자는 그 동안 아무런 작업도 할 수 없음.
- **동기 + 논블로킹: 순서대로 진행되지만 전체 시스템 입장에서 멈추지 않고 동작함.**
    - **예시 문장 1:**
        
        "게임에서 새로운 맵을 로드할 때, 로딩 진행률을 실시간으로 화면에 보여주면서도 화면 애니메이션이나 사용자 입력은 계속 처리된다."
        
    - **예시 문장 2:**
        
        "웹 브라우저가 페이지를 요청하면, 페이지 내용이 로드되는 동안 로딩바를 업데이트하지만 다른 인터페이스 기능은 멈추지 않고 동작한다."
        
    
    ![image](https://github.com/user-attachments/assets/e86a226e-79ed-411b-8e4f-547471a80d11)

    
- API는 동기적으로 결과를 반환하는 것처럼 보이나, 내부적으로는 **논블로킹 I/O**를 사용하여 OS 자원을 효율적으로 사용
- 호출자는 결과를 받을 때까지 기다리지만, 그 과정에서 OS는 다른 작업을 처리할 수 있음.

*(실제 개발에서는 동기 호출은 보통 블로킹이지만, 내부적으로 논블로킹 방식으로 구현된 경우가 있다)*

### 6. 비동기 I/O와 논블로킹 I/O는 같은 개념인가요? 두 개념이 어떻게 다르다고 생각하시나요?

- **비동기 I/O:**
    - 작업 요청 후 **즉시 제어권 반환**
    - 작업 완료 시 시스템이 **콜백이나 이벤트로 결과를 알려줌**
    - 호출자가 직접 결과를 폴링하지 않아도 됨.
- **논블로킹 I/O:**
    - 호출 시 **즉시 반환**하지만, 작업 결과가 바로 준비되지 않을 수 있음
    - 호출자가 주기적으로 상태를 확인하거나, 별도의 메커니즘으로 결과를 받아야 함.
